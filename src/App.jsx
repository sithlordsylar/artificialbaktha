import React, { useState, useEffect, useCallback } from 'react';

// Main App component for the Contextual Q&A application
const App = () => {
  // State for OpenRouter API Key, loaded from sessionStorage on initial render
  const [openRouterApiKey, setOpenRouterApiKey] = useState(() => {
    return sessionStorage.getItem('openRouterApiKey') || '';
  });
  // State to hold the user's question input
  const [question, setQuestion] = useState('');
  // State to manage which context document is currently selected (e.g., 'bible_genesis.txt' or 'unsure')
  const [selectedContextFile, setSelectedContextFile] = useState('unsure'); // Default to 'unsure'
  // State to store the content of the currently loaded context file
  const [currentContextContent, setCurrentContextContent] = useState('');
  // State to hold a list of available context files, fetched dynamically from file_list.json
  const [availableContextFiles, setAvailableContextFiles] = useState([]);
  // State to store the keyword mappings for each document, fetched from document_keywords.json
  const [documentKeywords, setDocumentKeywords] = useState({});
  // State to store external references and name relations, fetched from references_and_relations.json
  const [referencesAndRelations, setReferencesAndRelations] = useState({});
  // State to store alternative names mapping, fetched from alt_names_mapping.json
  const [altNamesMapping, setAltNamesMapping] = useState({});
  // State to hold the list of matched answer snippets returned by the AI
  const [matchedAnswers, setMatchedAnswers] = useState([]);
  // State to hold the exact relevant text passage from the document, as identified by the AI
  const [exactAnswer, setExactAnswer] = useState('');
  // State to hold the TLDR (Too Long; Didn't Read) summary generated by the AI
  const [tldrSummary, setTldrSummary] = useState('');
  // State to indicate if the AI is currently processing the request (for loading UI)
  const [isLoading, setIsLoading] = useState(false);
  // State to indicate if a context file is currently being loaded (for single file mode)
  const [isContextLoading, setIsContextLoading] = useState(false);
  // State to indicate if all initial metadata (JSON files) is being loaded
  const [isMetaDataLoading, setIsMetaDataLoading] = useState(true);
  // State to store any error messages that occur during the process
  const [error, setError] = useState('');
  // State to control the visibility of the API key help modal
  const [showApiKeyHelp, setShowApiKeyHelp] = useState(false);
  // New state for "Proper Research" mode
  const [isProperResearchMode, setIsProperResearchMode] = useState(false);
  // State to show detailed loading progress for "Proper Research" mode
  const [researchProgress, setResearchProgress] = useState('');
  // State to hold the file suggested by the AI when in 'unsure' mode
  const [suggestedFile, setSuggestedFile] = useState('');
  // State for displaying OpenRouter credit balance
  const [creditBalance, setCreditBalance] = useState(null);
  // State to indicate if credit balance is being loaded
  const [isBalanceLoading, setIsBalanceLoading] = useState(false);
  // State for model selection
  const [availableModels, setAvailableModels] = useState([]);
  const [selectedModel, setSelectedModel] = useState('mistralai/mistral-small-3.2-24b-instruct');
  const [isModelSelectorOpen, setIsModelSelectorOpen] = useState(false);
  const [modelSearchTerm, setModelSearchTerm] = useState('');
  const [showFreeModelsOnly, setShowFreeModelsOnly] = useState(false);

  // Utility function to introduce a delay
  const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

  // Function to fetch and update the credit balance from OpenRouter
  const fetchCreditBalance = useCallback(async () => {
    if (!openRouterApiKey) {
      setCreditBalance(null);
      return;
    }
    setIsBalanceLoading(true);
    try {
      const response = await fetch('https://openrouter.ai/api/v1/credits', {
        headers: {
          'Authorization': `Bearer ${openRouterApiKey}`,
        },
      });
      if (!response.ok) {
        // Handle cases where the key is invalid or has insufficient permissions
        if (response.status === 401 || response.status === 403) {
          setCreditBalance({ error: 'Invalid or unauthorized API Key for credits.' });
        } else {
          throw new Error(`Failed to fetch credits: ${response.statusText}`);
        }
      } else {
        const data = await response.json();
        const remaining = data.data.total_credits - data.data.total_usage;
        setCreditBalance({ remaining: remaining.toFixed(4) });
      }
    } catch (err) {
      console.error('Credit balance fetch error:', err);
      setCreditBalance({ error: 'Failed to fetch balance.' });
    } finally {
      setIsBalanceLoading(false);
    }
  }, [openRouterApiKey]); // Dependency on the API key

  // Effect to fetch credit balance when the component mounts or the API key changes
  useEffect(() => {
    fetchCreditBalance();
  }, [fetchCreditBalance]);

  // Effect to load all metadata (file list, keywords, references, alt names) from JSON files
  useEffect(() => {
    // Fetch the list of available models from OpenRouter
    const fetchModels = async () => {
      try {
        const response = await fetch('https://openrouter.ai/api/v1/models');
        if (!response.ok) {
          throw new Error('Failed to fetch models from OpenRouter.');
        }
        const data = await response.json();
        setAvailableModels(data.data);
      } catch (err) {
        console.error('Error fetching models:', err);
        // Handle the error, maybe show a message to the user
      }
    };

    const loadMetaData = async () => {
      fetchModels(); // Fire off the model fetching
      setIsMetaDataLoading(true);
      setError('');
      try {
        // --- Fetch file_list.json ---
        // Prepend import.meta.env.BASE_URL to correctly resolve path on GitHub Pages
        const fileListResponse = await fetch(`${import.meta.env.BASE_URL}context/file_list.json`);
        if (!fileListResponse.ok) {
          throw new Error(`Failed to load file_list.json: ${fileListResponse.statusText}. Make sure it exists in public/context/.`);
        }
        const fileList = await fileListResponse.json();
        setAvailableContextFiles(fileList);

        // --- Fetch document_keywords.json ---
        // Prepend import.meta.env.BASE_URL
        const keywordsResponse = await fetch(`${import.meta.env.BASE_URL}context/document_keywords.json`);
        if (!keywordsResponse.ok) {
          throw new Error(`Failed to load document_keywords.json: ${keywordsResponse.statusText}. Make sure it exists in public/context/.`);
        }
        const keywords = await keywordsResponse.json();
        setDocumentKeywords(keywords);

        // --- Fetch references_and_relations.json ---
        // Prepend import.meta.env.BASE_URL
        const referencesResponse = await fetch(`${import.meta.env.BASE_URL}context/references_and_relations.json`);
        if (!referencesResponse.ok) {
          throw new Error(`Failed to load references_and_relations.json: ${referencesResponse.statusText}. Make sure it exists in public/context/.`);
        }
        const references = await referencesResponse.json();
        setReferencesAndRelations(references);

        // --- Fetch alt_names_mapping.json ---
        // Prepend import.meta.env.BASE_URL
        const altNamesResponse = await fetch(`${import.meta.env.BASE_URL}context/alt_names_mapping.json`);
        if (!altNamesResponse.ok) {
          throw new Error(`Failed to load alt_names_mapping.json: ${altNamesResponse.statusText}. Make sure it exists in public/context/.`);
        }
        const altNames = await altNamesResponse.json();
        setAltNamesMapping(altNames);

        // Set default selected file to 'unsure' or the first available file
        if (fileList.length > 0) {
          setSelectedContextFile('unsure'); // Default to 'unsure'
        }
      } catch (err) {
        setError(`Error loading application metadata: ${err.message}`);
        console.error('Metadata loading error:', err);
      } finally {
        setIsMetaDataLoading(false);
      }
    };

    loadMetaData();
  }, []); // Empty dependency array means this effect runs only once on component mount

  // Effect to load the content of the currently selected context file (only for non-unsure, non-proper-research mode)
  useEffect(() => {
    const loadContextFileContent = async () => {
      // Do not load content if 'unsure' is selected or if in proper research mode,
      // as content will be determined dynamically or fetched in a loop.
      if (!selectedContextFile || selectedContextFile === 'unsure' || isProperResearchMode) {
        setCurrentContextContent('');
        return;
      }

      setIsContextLoading(true);
      setError('');

      try {
        // Prepend import.meta.env.BASE_URL
        const filePath = `${import.meta.env.BASE_URL}context/${selectedContextFile}`;
        const response = await fetch(filePath);

        if (!response.ok) {
          throw new Error(`Failed to load context file: ${response.statusText}`);
        }

        const text = await response.text();
        setCurrentContextContent(text);
      } catch (err) {
        setError(`Error loading context file: ${err.message}. Make sure '${selectedContextFile}' exists in 'public/context/'.`);
        console.error('Context file loading error:', err);
        setCurrentContextContent('');
      } finally {
        setIsContextLoading(false);
      }
    };

    loadContextFileContent();
  }, [selectedContextFile, isProperResearchMode]); // Re-run when selectedContextFile or research mode changes

  // Function to normalize the question by replacing alt names with canonical names
  // and removing punctuation. This is used for keyword matching and AI prompt.
  const normalizeQuestion = useCallback((questionText) => {
    let normalizedText = questionText.toLowerCase();

    // Replace alt names with canonical names. This should be done before stripping punctuation
    // to match alt names that might contain it (e.g., "Ste'Vi").
    for (const altName in altNamesMapping) {
      // Use a case-insensitive regex based on the original altName key.
      const regex = new RegExp(`\\b${altName.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\b`, 'gi');
      normalizedText = normalizedText.replace(regex, altNamesMapping[altName]);
    }

    // Now, perform aggressive normalization for keyword matching on the text with canonical names.
    // This handles possessives and removes all punctuation.
    normalizedText = normalizedText
      .toLowerCase() // Re-lowercase after replacements
      .replace(/'s\b/g, '') // Remove possessive 's (e.g., "samaji's" -> "samaji")
      .replace(/[^\w\s]/g, '') // Remove all remaining non-alphanumeric characters
      .replace(/\s+/g, ' ') // Collapse whitespace
      .trim();

    return normalizedText;
  }, [altNamesMapping]); // Recalculate if altNamesMapping changes

  // Function to suggest the best context file based on the question's normalized keywords
  const suggestContextFile = useCallback((questionText) => {
    // Only proceed if documentKeywords is loaded and not empty
    if (Object.keys(documentKeywords).length === 0) {
      console.warn("documentKeywords not loaded or empty. Cannot suggest context file.");
      return '';
    }

    const normalizedQuestion = normalizeQuestion(questionText); // Normalize the question first
    // Split into words, filter out any empty strings that might result from splitting
    const questionWords = normalizedQuestion.split(' ').filter(word => word.length > 0); 

    if (questionWords.length === 0) {
      console.log("No significant words in the question after normalization. Cannot suggest context file.");
      return '';
    }

    let bestMatchFile = '';
    let maxScore = 0;

    console.log(`--- Suggesting Context File for: "${questionText}" (Normalized: "${normalizedQuestion}") ---`);
    console.log("Question words for matching:", questionWords); // Now this should show actual words

    // NOTE: documentKeywords is indexed by filename, so we need to iterate through availableContextFiles
    // which now contains objects { filename, displayName }
    for (const fileInfo of availableContextFiles) { // Iterate over the objects
      const fileName = fileInfo.filename; // Get the actual filename
      const fileKeywords = documentKeywords[fileName]
        ? documentKeywords[fileName].flatMap(kw =>
            kw.toLowerCase()
              .replace(/'s\b/g, '') // Remove possessive 's
              .replace(/[^\w\s]/g, '') // Remove punctuation
              .split(' ') // Split multi-word keywords
          ).filter(word => word.length > 0) // Filter out empty strings
        : [];

      let currentScore = 0;
      questionWords.forEach(qWord => {
        if (fileKeywords.includes(qWord)) {
          currentScore++;
        }
      });
      console.log(`File: ${fileName}, Keywords (processed): ${fileKeywords.join(', ')}, Score: ${currentScore}`);

      if (currentScore > maxScore) {
        maxScore = currentScore;
        bestMatchFile = fileName;
      }
    }
    console.log(`Best match found: ${bestMatchFile} with score: ${maxScore}`);
    // Only suggest if a score is greater than 0, meaning at least one keyword matched
    return maxScore > 0 ? bestMatchFile : '';
  }, [documentKeywords, normalizeQuestion, availableContextFiles]); // Added availableContextFiles to dependencies

  // This effect clears the suggestion if we are no longer in 'unsure' mode or if in proper research mode
  useEffect(() => {
    if (selectedContextFile !== 'unsure' || isProperResearchMode) {
      setSuggestedFile('');
    }
  }, [selectedContextFile, isProperResearchMode]);

  // Effect to automatically SUGGEST a file when the question changes and we are in 'unsure' mode.
  // This effect does NOT load the content, it only sets the `suggestedFile` state.
  useEffect(() => {
    // Clear suggestion immediately if conditions aren't met while in 'unsure' mode
    if (selectedContextFile !== 'unsure' || question.length <= 5 || isProperResearchMode) {
      setSuggestedFile('');
      return;
    }

    // Only proceed to suggest if metadata is loaded
    if (Object.keys(documentKeywords).length > 0 && Object.keys(altNamesMapping).length > 0) {
      const fileSuggestion = suggestContextFile(question);
      setSuggestedFile(fileSuggestion); // Set the suggestion (or '' if none found)
    }
  }, [question, selectedContextFile, documentKeywords, altNamesMapping, isProperResearchMode]); // Re-run when question or mode changes

  // Effect to load the content of the SUGGESTED file, but only when in 'unsure' mode.
  useEffect(() => {
    const loadSuggestedFileContent = async () => {
      // Only run if we are in 'unsure' mode and there IS a suggested file.
      if (selectedContextFile !== 'unsure' || !suggestedFile) {
        setCurrentContextContent(''); // Clear content if no suggestion
        return;
      }

      setIsContextLoading(true);
      setError('');
      try {
        const filePath = `${import.meta.env.BASE_URL}context/${suggestedFile}`;
        const response = await fetch(filePath);
        if (!response.ok) {
          throw new Error(`Failed to load suggested context file: ${response.statusText}`);
        }
        const text = await response.text();
        setCurrentContextContent(text);
      } catch (err) {
        setError(`Error loading suggested context file: ${err.message}.`);
        console.error('Suggested context file loading error:', err);
        setCurrentContextContent('');
      } finally {
        setIsContextLoading(false);
      }
    };

    loadSuggestedFileContent();
  }, [suggestedFile, selectedContextFile]); // This effect depends only on the suggestion and mode.

const fetchWithRetry = async (url, options, retries = 5, delay = 5000) => {
  for (let i = 0; i < retries; i++) {
    const res = await fetch(url, options);
    if (res.status === 429) {
      console.warn(`⚠️ 429 rate limit hit. Waiting ${delay/1000}s before retry ${i+1}/${retries}...`);
      await sleep(delay);
      continue;
    }
    return res;
  }
  throw new Error(`Too many 429s. Retry limit reached.`);
};


  // Function to handle the "Ask Question" button click
  const handleAskQuestion = async () => {
    setError('');
    setIsLoading(true);
    setResearchProgress(''); // Clear previous progress messages

    // --- Validation Checks ---
    if (!openRouterApiKey) {
      setError('Please upload your OpenRouter API Key file to proceed.');
      setIsLoading(false);
      return;
    }
    if (!question.trim()) {
      setError('Please enter a question.');
      setIsLoading(false);
      return;
    }

    const normalizedQuestionForAI = normalizeQuestion(question);
    
    try {
      // Convert referencesAndRelations and altNamesMapping objects to strings for the AI prompt
      const referencesString = JSON.stringify(referencesAndRelations, null, 2);
      const altNamesString = JSON.stringify(altNamesMapping, null, 2);

      let finalContextForAI = '';
      let finalSelectedFileName = '';

      if (isProperResearchMode) {
        // --- Proper Research Mode: Multi-step AI analysis ---
        setResearchProgress('Starting deep research across documents...');
        const aggregatedSummaries = [];
        const relevantFiles = [];

        // First, determine which files are relevant based on keywords
        // This helps avoid sending empty documents to the AI and saves tokens/time
        // Iterate over the objects in availableContextFiles
        for (const fileInfo of availableContextFiles) { // MODIFIED
            const fileName = fileInfo.filename; // MODIFIED: Get the actual filename
            const normalizedQuestionWords = normalizedQuestionForAI.split(' ').filter(word => word.length > 0);
            const fileKeywords = documentKeywords[fileName]
                ? documentKeywords[fileName].flatMap(kw =>
                    kw.toLowerCase()
                      .replace(/'s\b/g, '') // Remove possessive 's
                      .replace(/[^\w\s]/g, '') // Remove punctuation
                      .split(' ')
                  ).filter(word => word.length > 0)
                : [];
            
            const score = normalizedQuestionWords.filter(qWord => fileKeywords.includes(qWord)).length;

            if (score > 0) { // Only include files with at least one matching keyword
                relevantFiles.push(fileName);
            }
        }

        if (relevantFiles.length === 0) {
          setError('No relevant documents found for deep research. Please refine your question or keywords.');
          setIsLoading(false);
          return;
        }

        // Loop through relevant files, summarize each, and aggregate
        for (let i = 0; i < relevantFiles.length; i++) {
          const fileName = relevantFiles[i];
          // Find the displayName for the progress message
          const fileDisplayName = availableContextFiles.find(f => f.filename === fileName)?.displayName || fileName.replace('.txt', ''); // MODIFIED
          setResearchProgress(`Analyzing document ${i + 1} of ${relevantFiles.length}: ${fileDisplayName}...`); // MODIFIED
          
          // Prepend import.meta.env.BASE_URL
          const filePath = `${import.meta.env.BASE_URL}context/${fileName}`;
          const response = await fetch(filePath);
          if (!response.ok) {
            console.warn(`Could not load document ${fileName} for research: ${response.statusText}`);
            continue; // Skip this file if it can't be loaded
          }
          const documentContent = await response.text();

          // Sub-query prompt for individual document summarization
          const subQueryPrompt = `Given the following document and the user's main question, extract and concisely summarize ONLY the information relevant to the question from THIS DOCUMENT. If no information is relevant, state 'No relevant information found in this document.'
          Document: """${documentContent}"""
          Main Question: "${normalizedQuestionForAI}"
          Summarize relevant information from this document:`;

          const subQueryResult = await fetchWithRetry('https://openrouter.ai/api/v1/chat/completions', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${openRouterApiKey}`,
              'HTTP-Referer': window.location.href,
              'X-Title': 'SamaLore Contextual Q&A App - SubQuery'
            },
            body: JSON.stringify({
              model: selectedModel,
              messages: [{ role: 'user', content: subQueryPrompt }],
              // No response_format: { type: "json_object" } for sub-queries, expect plain text
            })
          });

          if (!subQueryResult.ok) {
            const errorData = await subQueryResult.json();
            console.error(`Sub-query API error for ${fileName}: ${subQueryResult.status} - ${errorData.message || 'Unknown error'}`);
            // If it's a 429, we might want to retry or increase delay. For now, just warn and continue.
            continue; // Continue to next file even if one fails
          }
          const subResultJson = await subQueryResult.json();
          const summary = subResultJson.choices[0]?.message?.content || 'No summary generated.';
          
          if (summary && summary.toLowerCase() !== 'no relevant information found in this document.') {
            aggregatedSummaries.push(`--- Summary from ${fileDisplayName} ---\n${summary}\n`); // MODIFIED
          }

          // Introduce a delay to avoid hitting rate limits
          await sleep(3000); // 3 second delay between sub-queries. Adjust if needed.
        }

        if (aggregatedSummaries.length === 0) {
          setError('No relevant information found across any documents for your question.');
          setIsLoading(false);
          return;
        }

        finalContextForAI = aggregatedSummaries.join('\n\n');
        finalSelectedFileName = 'Aggregated Research'; // Indicate this is a synthesized context
        setResearchProgress('Synthesizing final answer...');

        // Final Synthesis Prompt
        const finalPrompt = `You have been provided with multiple summaries from different documents, all related to the user's original question.
        Synthesize these summaries into a single, comprehensive 'exact_answer_text' and a 'tldr_summary'.
        For 'exact_answer_text', combine the most relevant details from the provided summaries into a coherent, detailed answer. Do not quote verbatim from the original documents, but rather integrate the information from the summaries.
        For 'tldr_summary', provide a concise, high-level overview and direct answer, potentially including external relations if they were part of the initial 'referencesAndRelations' context.

        Aggregated Summaries:
        """
        ${finalContextForAI}
        """

        Additional Reference Context (for external relations, do not directly quote into exact_answer_text):
        """
        ${referencesString}
        """

        Alternative Name Mappings (for understanding terms):
        """
        ${altNamesString}
        """

        Original Question: "${normalizedQuestionForAI}"

        Your response MUST be a JSON object with the following structure:
        {
          "matched_answers": [],
          "exact_answer_text": "A comprehensive, synthesized answer based on all provided summaries.",
          "tldr_summary": "A concise summary and direct answer to the question, potentially enriched by additional reference context."
        }
        `;

        const finalResponse = await fetchWithRetry('https://openrouter.ai/api/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${openRouterApiKey}`,
            'HTTP-Referer': window.location.href,
            'X-Title': 'SamaLore Contextual Q&A App - Final Synthesis'
          },
          body: JSON.stringify({
            model: selectedModel,
            messages: [{ role: 'user', content: finalPrompt }],
            response_format: { type: "json_object" },
            schema: {
              type: "object",
              properties: {
                "matched_answers": { type: "array", items: { "type": "string" } },
                "exact_answer_text": { "type": "string" },
                "tldr_summary": { "type": "string" }
              },
              required: ["matched_answers", "exact_answer_text", "tldr_summary"]
            }
          })
        });

        if (!finalResponse.ok) {
          const errorData = await finalResponse.json();
          throw new Error(`Final synthesis API error: ${finalResponse.status} - ${errorData.message || 'Unknown error'}`);
        }

        const finalResult = await finalResponse.json();
        if (finalResult.choices && finalResult.choices.length > 0 && finalResult.choices[0].message && finalResult.choices[0].message.content) {
          const jsonResponse = finalResult.choices[0].message.content;
          const parsedJson = JSON.parse(jsonResponse);

          setMatchedAnswers(parsedJson.matched_answers || []); // Will be empty in this mode
          setExactAnswer(parsedJson.exact_answer_text || 'No comprehensive answer found.');
          setTldrSummary(parsedJson.tldr_summary || 'No summary available.');
        } else {
          setError('Failed to get a valid final synthesis response from the AI.');
          console.error('Final AI response structure unexpected or empty:', finalResult);
        }

      } else {
        // --- Standard Mode (Single Document Lookup) ---
        let contextToUse = currentContextContent;
        let finalSelectedFile = selectedContextFile;
        // --- Refactored Logic for 'unsure' mode ---
        if (selectedContextFile === 'unsure') {
          // The suggestedFile state is now the single source of truth for the suggested document.
          // The useEffect hooks have already loaded its content into currentContextContent.
          finalSelectedFile = suggestedFile;

          if (!finalSelectedFile) {
            setError('Could not determine a relevant document from your question. Please select a specific document or refine your question.');
            setIsLoading(false);
            return;
          }
          // The content is already pre-loaded by the useEffect hook that watches `suggestedFile`.
          // No need to re-fetch here. `contextToUse` is already set to `currentContextContent`.
        }

        if (!contextToUse.trim()) {
          setError('Context document content is empty. Please ensure the selected file has content. This might happen if "Unsure" could not find a match.');
          setIsLoading(false);
          return;
        }

        // Standard Mode Prompt (for verbatim section extraction)
        const prompt = `Given the following primary context, additional reference context, and alternative name mappings, answer the question comprehensively.

        For 'exact_answer_text':
        Identify the *single most relevant section* in the PRIMARY context that directly answers or contains the information for the question.
        This section is typically defined by a prominent marker at its beginning (e.g., [Chapter 1], Verse 5:, ##Section Name, [Book Title], [Kunju Name], [About Kunju #1], [Kunju #1], [Name (Origin Part) - Sphere of Influence]).
        Extract the *entire, verbatim text* of this relevant section. This means copying all text from the identified starting marker up to, but not including, the next similar section marker, or until the end of the document if no further section markers are found.
        Include the section's defining marker in the extracted text. Do NOT summarize, paraphrase, or omit any part of this identified section.

        For 'tldr_summary':
        Provide a concise summary of the answer AND directly answer the question based on your understanding of the PRIMARY context. If relevant, and only if it naturally enhances the explanation, you may include information from the ADDITIONAL REFERENCE CONTEXT to provide external relations or common knowledge, but do not force it.

        Use the ALTERNATIVE NAME MAPPINGS to understand variations of names or terms mentioned in the question or context.

        Primary Context (from ${finalSelectedFile}):
        """
        ${contextToUse}
        """

        Additional Reference Context (for external relations, do not directly quote into exact_answer_text):
        """
        ${referencesString}
        """

        Alternative Name Mappings (use to understand alternate spellings/names):
        """
        ${altNamesString}
        """

        Question: "${normalizedQuestionForAI}"

        Your response MUST be a JSON object with the following structure. Do NOT include any other text or formatting outside this JSON structure.
        {
          "matched_answers": ["snippet 1", "snippet 2", ...],
          "exact_answer_text": "The full relevant section from the primary context, including its defining marker, copied verbatim.",
          "tldr_summary": "A concise summary and direct answer to the question, potentially enriched by additional reference context."
        }
        `;

        const response = await fetchWithRetry('https://openrouter.ai/api/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${openRouterApiKey}`,
            'HTTP-Referer': window.location.href,
            'X-Title': 'SamaLore Contextual Q&A App'
          },
          body: JSON.stringify({
            model: selectedModel,
            messages: [{ role: 'user', content: prompt }],
            response_format: { type: "json_object" },
            schema: {
              type: "object",
              properties: {
                "matched_answers": { type: "array", items: { "type": "string" } },
                "exact_answer_text": { "type": "string" },
                "tldr_summary": { "type": "string" }
              },
              required: ["matched_answers", "exact_answer_text", "tldr_summary"]
            }
          })
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(`OpenRouter API error: ${response.status} - ${errorData.message || 'Unknown error'}`);
        }

        const result = await response.json();

        if (result.choices && result.choices.length > 0 && result.choices[0].message && result.choices[0].message.content) {
          const jsonResponse = result.choices[0].message.content;
          const parsedJson = JSON.parse(jsonResponse);

          setMatchedAnswers(parsedJson.matched_answers || []);
          setExactAnswer(parsedJson.exact_answer_text || 'No exact answer found.');
          setTldrSummary(parsedJson.tldr_summary || 'No summary available.');
        } else {
          setError('Failed to get a valid response from the AI. The AI might not have returned the expected JSON format. Check console for raw response.');
          console.error('AI response structure unexpected or empty:', result);
        }
      }
    } catch (err) {
      setError(`An error occurred: ${err.message}. Check console for details.`);
      console.error('Fetch error:', err);
    } finally {
      setIsLoading(false);
      setResearchProgress(''); // Clear progress message
    }
  };

  const handleSelectAnswer = (answerText) => {
    console.log("Clicked matched answer snippet:", answerText);
    // For now, clicking a snippet does not change the main exactAnswer/tldrSummary,
    // as those are the AI's best overall response to the original question.
    // If you want to highlight the snippet within the exactAnswer, that's a UI enhancement.
  };

  // Handle .env file upload
  const handleEnvFileUpload = (e) => {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (event) => {
        const content = event.target.result;
        // Improved regex to find the key, ignore comments, and trim whitespace.
        const match = content.match(/^\s*OPENROUTER_API_KEY\s*=\s*['"]?([^'"#\s]+)['"]?/m);
        if (match && match[1]) {
          const key = match[1]; // No need to trim, regex handles it.
          setOpenRouterApiKey(key);
          sessionStorage.setItem('openRouterApiKey', key);
          setError('');
          alert('API Key loaded from .env file!'); // Using alert for simplicity, consider custom modal
        } else {
          setError('Could not find OPENROUTER_API_KEY in the .env file. Please check the format: OPENROUTER_API_KEY=your_key');
        }
      };
      reader.onerror = () => {
        setError('Error reading .env file.');
      };
      reader.readAsText(file);
    }
  };

  // Function to clear the entire instance
  const clearInstance = () => {
    setOpenRouterApiKey('');
    sessionStorage.removeItem('openRouterApiKey');
    setQuestion('');
    setSelectedContextFile('unsure');
    setCurrentContextContent('');
    setMatchedAnswers([]);
    setExactAnswer('');
    setTldrSummary('');
    setError('');
    setIsLoading(false);
    setIsContextLoading(false);
    setResearchProgress('');
    alert('Instance cleared! API Key removed from session storage.'); // Using alert for simplicity
  };

  const filteredModels = availableModels.filter(model => {
    const matchesSearch = model.name.toLowerCase().includes(modelSearchTerm.toLowerCase()) || model.id.toLowerCase().includes(modelSearchTerm.toLowerCase());
    const matchesFilter = !showFreeModelsOnly || (model.pricing.prompt === "0" && model.pricing.completion === "0");
    return matchesSearch && matchesFilter;
  });

  return (
    <div className="min-h-screen bg-gray-100 p-4 font-sans flex flex-col items-center">
        {isModelSelectorOpen && (
            <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50">
                <div className="bg-white rounded-lg shadow-2xl p-6 w-full max-w-2xl max-h-[80vh] flex flex-col">
                    <h2 className="text-2xl font-bold mb-4">Select a Model</h2>
                    {/* Search and Filter Controls */}
                    <div className="flex gap-4 mb-4">
                        <input
                            type="text"
                            placeholder="Search models..."
                            value={modelSearchTerm}
                            onChange={(e) => setModelSearchTerm(e.target.value)}
                            className="flex-grow p-2 border rounded-md"
                        />
                        <label className="flex items-center gap-2">
                            <input
                                type="checkbox"
                                checked={showFreeModelsOnly}
                                onChange={(e) => setShowFreeModelsOnly(e.target.checked)}
                                className="h-5 w-5"
                            />
                            <span>Show Free Models Only</span>
                        </label>
                    </div>
                    {/* Models List */}
                    <div className="overflow-y-auto border rounded-md p-2 flex-grow">
                        {filteredModels.length > 0 ? (
                            filteredModels.map(model => (
                                <div
                                    key={model.id}
                                    onClick={() => {
                                        setSelectedModel(model.id);
                                        setIsModelSelectorOpen(false);
                                    }}
                                    className={`p-3 rounded-md cursor-pointer hover:bg-gray-100 ${selectedModel === model.id ? 'bg-blue-100 border-l-4 border-blue-500' : ''}`}
                                >
                                    <p className="font-semibold text-lg">{model.name}</p>
                                    <p className="font-mono text-sm text-gray-600">{model.id}</p>
                                    <p className="text-sm mt-1">{model.description}</p>
                                    <div className="text-xs mt-2 text-gray-500">
                                        <span>Context: {model.context_length.toLocaleString()}</span>
                                        <span className="mx-2">|</span>
                                        <span>Prompt: ${model.pricing.prompt}/token</span>
                                        <span className="mx-2">|</span>
                                        <span>Completion: ${model.pricing.completion}/token</span>
                                    </div>
                                </div>
                            ))
                        ) : (
                            <p className="text-center text-gray-500 py-4">No models match your criteria.</p>
                        )}
                    </div>
                    <button
                        onClick={() => setIsModelSelectorOpen(false)}
                        className="mt-4 px-4 py-2 bg-red-600 text-white font-semibold rounded-md hover:bg-red-700 self-end"
                    >
                        Close
                    </button>
                </div>
            </div>
        )}
      <div className="w-full max-w-4xl bg-white rounded-lg shadow-xl p-6 space-y-6">
        {/* Application Title */}
        <h1 className="text-3xl font-bold text-center text-gray-800 mb-6">SamaLore Contextual Q&A App</h1>

        {/* API Key Input Section (with .env upload) */}
        <div className="bg-blue-50 p-4 rounded-md border border-blue-200">
          <label htmlFor="envFileUpload" className="block text-lg font-medium text-blue-800 mb-2">
            Upload OpenRouter API Key (.env file)
            <button
              onClick={() => setShowApiKeyHelp(!showApiKeyHelp)}
              className="ml-2 text-blue-600 hover:text-blue-800 font-bold text-xl leading-none"
              title="Click for API Key help"
            >
              ?
            </button>
          </label>
          <input
            type="file"
            id="envFileUpload"
            accept=".env"
            onChange={handleEnvFileUpload}
            className="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"
          />
          {openRouterApiKey && (
            <p className="mt-2 text-sm text-green-700">API Key loaded successfully!</p>
          )}

          {showApiKeyHelp && (
            <div className="mt-3 p-3 bg-blue-100 rounded-md text-blue-700 text-sm">
              <p className="font-semibold mb-2">How to get your OpenRouter API Key and create the .env file:</p>
              <ol className="list-decimal list-inside space-y-1">
                <li>Go to <a href="https://openrouter.ai/keys" target="_blank" rel="noopener noreferrer" className="text-blue-600 underline">OpenRouter.ai/keys</a></li>
                <li>Sign in or create an account.</li>
                <li>Click "Create New Key".</li>
                <li>Create a new file on your computer named `.env` (just `.env`, no filename before it).</li>
                <li>Inside this `.env` file, paste your copied API key in this format: <code className="font-mono bg-blue-200 p-1 rounded">OPENROUTER_API_KEY=your_copied_key_here</code></li>
                <li>Save the `.env` file and then upload it using the button above.</li>
              </ol>
              <p className="mt-2 font-semibold text-red-700">
                **Security Warning:** While this method avoids hardcoding, the key is still loaded into your browser's memory and session storage. For public applications, a secure backend (e.g., serverless function) is highly recommended to protect your API key. For internal use, ensure all users are aware of this.
              </p>
            </div>
          )}
        </div>

        {/* Credit Balance Display */}
        {openRouterApiKey && (
            <div className="bg-gray-50 p-4 rounded-md border border-gray-200">
                <h2 className="text-lg font-medium text-gray-800 mb-2">Credit Balance</h2>
                {isBalanceLoading ? (
                    <p className="text-gray-500">Loading balance...</p>
                ) : creditBalance ? (
                    creditBalance.error ? (
                        <p className="text-red-600 font-semibold">{creditBalance.error}</p>
                    ) : (
                        <p className="text-2xl font-bold text-green-600">${creditBalance.remaining}</p>
                    )
                ) : (
                    <p className="text-gray-500">Enter a valid API key to see your balance.</p>
                )}
            </div>
        )}

        {/* Model Selector Button */}
        <div className="flex justify-between items-center bg-gray-50 p-3 rounded-md border">
            <div>
                <span className="font-medium text-gray-700">Selected Model:</span>
                <span className="ml-2 font-mono text-blue-600 bg-blue-50 p-1 rounded">{selectedModel}</span>
            </div>
            <button
                onClick={() => setIsModelSelectorOpen(true)}
                className="px-4 py-2 bg-purple-600 text-white font-semibold rounded-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500"
                disabled={!availableModels.length}
            >
                {availableModels.length ? 'Change Model' : 'Loading Models...'}
            </button>
        </div>

        {/* Context Document Selector, Question Input, and Ask Button */}
        <div className="flex flex-col gap-4">
          {/* Proper Research Checkbox */}
          <div className="flex items-center">
            <input
              type="checkbox"
              id="properResearchCheckbox"
              checked={isProperResearchMode}
              onChange={(e) => setIsProperResearchMode(e.target.checked)}
              className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
            />
            <label htmlFor="properResearchCheckbox" className="ml-2 block text-base font-medium text-gray-700">
              Enable Proper Research (multi-document analysis)
            </label>
          </div>

          {/* Context Document Selector */}
          <div>
            <label htmlFor="contextSelector" className="block text-lg font-medium text-gray-700 mb-2 whitespace-nowrap">
              Select Context Document (or type question for suggestion)
            </label>
            {isMetaDataLoading ? (
              <p className="text-gray-500">Loading context files and keywords...</p>
            ) : (
              <select
                id="contextSelector"
                className="w-full p-3 border border-gray-300 rounded-md bg-white focus:ring-blue-500 focus:border-blue-500"
                value={selectedContextFile}
                onChange={(e) => setSelectedContextFile(e.target.value)}
                disabled={isContextLoading || isMetaDataLoading || isProperResearchMode} // Disable if in proper research mode
              >
                <option value="unsure">Unsure (AI will suggest best document)</option>
                {/* MODIFIED: Use fileInfo.filename for a stable key and value */}
                {availableContextFiles.map((fileInfo) => (
                    <option key={fileInfo.filename} value={fileInfo.filename}>
                        {fileInfo.displayName}
                    </option>
                ))}
              </select>
            )}
            {isContextLoading && selectedContextFile === 'unsure' && (
              <p className="text-sm text-gray-500 mt-1">AI is determining best context...</p>
            )}
            {isContextLoading && selectedContextFile !== 'unsure' && (
              <p className="text-sm text-gray-500 mt-1">Loading selected context...</p>
            )}
          </div>

          {/* Question Input Field and Ask Button - now aligned horizontally */}
          <div className="flex flex-col md:flex-row gap-4 items-end">
            <div className="flex-grow w-full">
              <label htmlFor="questionInput" className="block text-lg font-medium text-gray-700 mb-2">
                Your Question
              </label>
              <input
                type="text"
                id="questionInput"
                className="w-full p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500"
                value={question}
                onChange={(e) => setQuestion(e.target.value)}
                placeholder="e.g., What is the prophecy about Samaji?"
              />
            </div>
            <button
              onClick={handleAskQuestion}
              className="w-full md:w-auto px-6 py-3 bg-blue-600 text-white font-semibold rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition duration-200 ease-in-out"
              disabled={isLoading || isContextLoading || isMetaDataLoading || !openRouterApiKey || (!currentContextContent && selectedContextFile !== 'unsure' && !isProperResearchMode)}
            >
              {isLoading ? (researchProgress || 'Thinking...') : 'Ask Question'}
            </button>
          </div>
        </div>

        {/* Error Display Area */}
        {error && (
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative" role="alert">
            <strong className="font-bold">Error!</strong>
            <span className="block sm:inline"> {error}</span>
          </div>
        )}

        {/* Output Fields */}
        <div className="space-y-6">
          {/* List of Matched Answers */}
          <div>
            <h2 className="text-xl font-semibold text-gray-800 mb-3">List of Matched Answers:</h2>
            <div className="bg-gray-50 p-4 rounded-md border border-gray-200 min-h-[80px]">
              {matchedAnswers.length > 0 ? (
                <ul className="list-disc list-inside space-y-2">
                  {matchedAnswers.map((answer, index) => (
                    <li key={`${answer}-${index}`}>
                      <button
                        onClick={() => handleSelectAnswer(answer)}
                        className="text-blue-600 hover:underline text-left"
                      >
                        {answer}
                      </button>
                    </li>
                  ))}
                </ul>
              ) : (
                <p className="text-gray-500">No matched answers yet. Ask a question!</p>
              )}
            </div>
          </div>

          {/* Exact Answer from Document */}
          <div>
            <h2 className="text-xl font-semibold text-gray-800 mb-3">Exact Answer from Document:</h2>
            <div className="bg-gray-50 p-4 rounded-md border border-gray-200 min-h-[120px] whitespace-pre-wrap">
              {exactAnswer ? (
                <p className="text-gray-700">{exactAnswer}</p>
              ) : (
                <p className="text-gray-500">The most relevant passage from the document will appear here.</p>
              )}
            </div>
          </div>

          {/* TLDR Summary */}
          <div>
            <h2 className="text-xl font-semibold text-gray-800 mb-3">TLDR Summary (Summary + AI's Answer):</h2>
            <div className="bg-gray-50 p-4 rounded-md border border-gray-200 min-h-[80px] whitespace-pre-wrap">
              {tldrSummary ? (
                <p className="text-gray-700">{tldrSummary}</p>
              ) : (
                <p className="text-gray-500">A concise summary and direct answer from the AI will appear here.</p>
              )}
            </div>
          </div>
        </div>

        {/* Clear Instance Button */}
        <div className="mt-6 text-center">
          <button
            onClick={clearInstance}
            className="px-6 py-3 bg-red-600 text-white font-semibold rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 transition duration-200 ease-in-out"
          >
            Clear Instance
          </button>
        </div>
      </div>
    </div>
  );
};

export default App;
