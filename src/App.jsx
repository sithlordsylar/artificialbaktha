import React, { useState, useEffect, useCallback } from 'react';

// Main App component for the Contextual Q&A application
const App = () => {
  // State for OpenRouter API Key, loaded from sessionStorage on initial render
  const [openRouterApiKey, setOpenRouterApiKey] = useState(() => {
    return sessionStorage.getItem('openRouterApiKey') || '';
  });
  // State to hold the user's question input
  const [question, setQuestion] = useState('');
  // State to manage which context document is currently selected (e.g., 'bible_genesis.txt' or 'unsure')
  const [selectedContextFile, setSelectedContextFile] = useState('unsure'); // Default to 'unsure'
  // State to store the content of the currently loaded context file
  const [currentContextContent, setCurrentContextContent] = useState('');
  // State to hold a list of available context files, fetched dynamically from file_list.json
  const [availableContextFiles, setAvailableContextFiles] = useState([]);
  // State to store the keyword mappings for each document, fetched from document_keywords.json
  const [documentKeywords, setDocumentKeywords] = useState({});
  // State to store external references and name relations, fetched from references_and_relations.json
  const [referencesAndRelations, setReferencesAndRelations] = useState({});
  // State to store alternative names mapping, fetched from alt_names_mapping.json
  const [altNamesMapping, setAltNamesMapping] = useState({});
  // State to hold the list of matched answer snippets returned by the AI
  const [matchedAnswers, setMatchedAnswers] = useState([]);
  // State to hold the exact relevant text passage from the document, as identified by the AI
  const [exactAnswer, setExactAnswer] = useState('');
  // State to hold the TLDR (Too Long; Didn't Read) summary generated by the AI
  const [tldrSummary, setTldrSummary] = useState('');
  // State to indicate if the AI is currently processing the request (for loading UI)
  const [isLoading, setIsLoading] = useState(false);
  // State to indicate if a context file is currently being loaded (for single file mode)
  const [isContextLoading, setIsContextLoading] = useState(false);
  // State to indicate if all initial metadata (JSON files) is being loaded
  const [isMetaDataLoading, setIsMetaDataLoading] = useState(true);
  // State to store any error messages that occur during the process
  const [error, setError] = useState('');
  // State to control the visibility of the API key help modal
  const [showApiKeyHelp, setShowApiKeyHelp] = useState(false);
  // New state for "Proper Research" mode
  const [isProperResearchMode, setIsProperResearchMode] = useState(false);
  // State to show detailed loading progress for "Proper Research" mode
  const [researchProgress, setResearchProgress] = useState('');

  // Utility function to introduce a delay
  const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

  // Effect to load all metadata (file list, keywords, references, alt names) from JSON files
  useEffect(() => {
    const loadMetaData = async () => {
      setIsMetaDataLoading(true);
      setError('');
      try {
        // --- Fetch file_list.json ---
        // Prepend import.meta.env.BASE_URL to correctly resolve path on GitHub Pages
        const fileListResponse = await fetch(`${import.meta.env.BASE_URL}context/file_list.json`);
        if (!fileListResponse.ok) {
          throw new Error(`Failed to load file_list.json: ${fileListResponse.statusText}. Make sure it exists in public/context/.`);
        }
        const fileList = await fileListResponse.json();
        setAvailableContextFiles(fileList);

        // --- Fetch document_keywords.json ---
        // Prepend import.meta.env.BASE_URL
        const keywordsResponse = await fetch(`${import.meta.env.BASE_URL}context/document_keywords.json`);
        if (!keywordsResponse.ok) {
          throw new Error(`Failed to load document_keywords.json: ${keywordsResponse.statusText}. Make sure it exists in public/context/.`);
        }
        const keywords = await keywordsResponse.json();
        setDocumentKeywords(keywords);

        // --- Fetch references_and_relations.json ---
        // Prepend import.meta.env.BASE_URL
        const referencesResponse = await fetch(`${import.meta.env.BASE_URL}context/references_and_relations.json`);
        if (!referencesResponse.ok) {
          throw new Error(`Failed to load references_and_relations.json: ${referencesResponse.statusText}. Make sure it exists in public/context/.`);
        }
        const references = await referencesResponse.json();
        setReferencesAndRelations(references);

        // --- Fetch alt_names_mapping.json ---
        // Prepend import.meta.env.BASE_URL
        const altNamesResponse = await fetch(`${import.meta.env.BASE_URL}context/alt_names_mapping.json`);
        if (!altNamesResponse.ok) {
          throw new Error(`Failed to load alt_names_mapping.json: ${altNamesResponse.statusText}. Make sure it exists in public/context/.`);
        }
        const altNames = await altNamesResponse.json();
        setAltNamesMapping(altNames);

        // Set default selected file to 'unsure' or the first available file
        if (fileList.length > 0) {
          setSelectedContextFile('unsure'); // Default to 'unsure'
        }
      } catch (err) {
        setError(`Error loading application metadata: ${err.message}`);
        console.error('Metadata loading error:', err);
      } finally {
        setIsMetaDataLoading(false);
      }
    };

    loadMetaData();
  }, []); // Empty dependency array means this effect runs only once on component mount

  // Effect to load the content of the currently selected context file (only for non-unsure, non-proper-research mode)
  useEffect(() => {
    const loadContextFileContent = async () => {
      // Do not load content if 'unsure' is selected or if in proper research mode,
      // as content will be determined dynamically or fetched in a loop.
      if (!selectedContextFile || selectedContextFile === 'unsure' || isProperResearchMode) {
        setCurrentContextContent('');
        return;
      }

      setIsContextLoading(true);
      setError('');

      try {
        // Prepend import.meta.env.BASE_URL
        const filePath = `${import.meta.env.BASE_URL}context/${selectedContextFile}`;
        const response = await fetch(filePath);

        if (!response.ok) {
          throw new Error(`Failed to load context file: ${response.statusText}`);
        }

        const text = await response.text();
        setCurrentContextContent(text);
      } catch (err) {
        setError(`Error loading context file: ${err.message}. Make sure '${selectedContextFile}' exists in 'public/context/'.`);
        console.error('Context file loading error:', err);
        setCurrentContextContent('');
      } finally {
        setIsContextLoading(false);
      }
    };

    loadContextFileContent();
  }, [selectedContextFile, isProperResearchMode]); // Re-run when selectedContextFile or research mode changes

  // Function to normalize the question by replacing alt names with canonical names
  // and removing punctuation. This is used for keyword matching and AI prompt.
  const normalizeQuestion = useCallback((questionText) => {
    // Convert to lowercase, replace common punctuation with a space, then trim and reduce multiple spaces
    let normalizedText = questionText.toLowerCase()
                                    .replace(/[^\w\s']/g, '') // Keep apostrophes for names like Ste'Vi
                                    .replace(/\s+/g, ' ') // Replace multiple spaces with single space
                                    .trim(); // Trim leading/trailing whitespace
    
    // Replace alt names with canonical ones
    for (const altName in altNamesMapping) {
      const regex = new RegExp(`\\b${altName}\\b`, 'g');
      normalizedText = normalizedText.replace(regex, altNamesMapping[altName].toLowerCase());
    }
    return normalizedText;
  }, [altNamesMapping]); // Recalculate if altNamesMapping changes

  // Function to suggest the best context file based on the question's normalized keywords
  const suggestContextFile = useCallback((questionText) => {
    // Only proceed if documentKeywords is loaded and not empty
    if (Object.keys(documentKeywords).length === 0) {
      console.warn("documentKeywords not loaded or empty. Cannot suggest context file.");
      return '';
    }

    const normalizedQuestion = normalizeQuestion(questionText); // Normalize the question first
    // Split into words, filter out any empty strings that might result from splitting
    const questionWords = normalizedQuestion.split(' ').filter(word => word.length > 0); 

    if (questionWords.length === 0) {
      console.log("No significant words in the question after normalization. Cannot suggest context file.");
      return '';
    }

    let bestMatchFile = '';
    let maxScore = 0;

    console.log(`--- Suggesting Context File for: "${questionText}" (Normalized: "${normalizedQuestion}") ---`);
    console.log("Question words for matching:", questionWords); // Now this should show actual words

    // NOTE: documentKeywords is indexed by filename, so we need to iterate through availableContextFiles
    // which now contains objects { filename, displayName }
    for (const fileInfo of availableContextFiles) { // Iterate over the objects
      const fileName = fileInfo.filename; // Get the actual filename
      const fileKeywords = documentKeywords[fileName]
        ? documentKeywords[fileName].flatMap(kw => kw.toLowerCase().replace(/[^\w\s']/g, '').split(' ')) // Split multi-word keywords and clean
        .filter(word => word.length > 0) // Filter out empty strings
        : [];

      let currentScore = 0;
      questionWords.forEach(qWord => {
        if (fileKeywords.includes(qWord)) {
          currentScore++;
        }
      });
      console.log(`File: ${fileName}, Keywords (processed): ${fileKeywords.join(', ')}, Score: ${currentScore}`);

      if (currentScore > maxScore) {
        maxScore = currentScore;
        bestMatchFile = fileName;
      }
    }
    console.log(`Best match found: ${bestMatchFile} with score: ${maxScore}`);
    // Only suggest if a score is greater than 0, meaning at least one keyword matched
    return maxScore > 0 ? bestMatchFile : '';
  }, [documentKeywords, normalizeQuestion, availableContextFiles]); // Added availableContextFiles to dependencies

  // Effect to automatically suggest context file when the question changes, if 'unsure' is selected
  useEffect(() => {
    // Only suggest if question is long enough, and all metadata is loaded, and not in proper research mode
    if (selectedContextFile === 'unsure' && question.length > 5 && Object.keys(documentKeywords).length > 0 && Object.keys(altNamesMapping).length > 0 && !isProperResearchMode) {
      const suggestedFile = suggestContextFile(question);
      if (suggestedFile) {
        // If a suggestion is found, load its content immediately for the 'unsure' mode
        const loadSuggestedFileContent = async () => {
          setIsContextLoading(true);
          setError('');
          try {
            // Prepend import.meta.env.BASE_URL
            const filePath = `${import.meta.env.BASE_URL}context/${suggestedFile}`;
            const response = await fetch(filePath);
            if (!response.ok) {
              throw new Error(`Failed to load suggested context file: ${response.statusText}`);
            }
            const text = await response.text();
            setCurrentContextContent(text);
          } catch (err) {
            setError(`Error loading suggested context file: ${err.message}.`);
            console.error('Suggested context file loading error:', err);
            setCurrentContextContent('');
          } finally {
            setIsContextLoading(false);
          }
        };
        loadSuggestedFileContent();
      } else {
        setCurrentContextContent(''); // Clear content if no suggestion is found for 'unsure'
      }
    }
  }, [question, documentKeywords, selectedContextFile, suggestContextFile, altNamesMapping, isProperResearchMode]); // Dependencies for this effect


  // Function to handle the "Ask Question" button click
  const handleAskQuestion = async () => {
    setError('');
    setIsLoading(true);
    setResearchProgress(''); // Clear previous progress messages

    // --- Validation Checks ---
    if (!openRouterApiKey) {
      setError('Please upload your OpenRouter API Key file to proceed.');
      setIsLoading(false);
      return;
    }
    if (!question.trim()) {
      setError('Please enter a question.');
      setIsLoading(false);
      return;
    }

    const normalizedQuestionForAI = normalizeQuestion(question);
    
    try {
      // Convert referencesAndRelations and altNamesMapping objects to strings for the AI prompt
      const referencesString = JSON.stringify(referencesAndRelations, null, 2);
      const altNamesString = JSON.stringify(altNamesMapping, null, 2);

      let finalContextForAI = '';
      let finalSelectedFileName = '';

      if (isProperResearchMode) {
        // --- Proper Research Mode: Multi-step AI analysis ---
        setResearchProgress('Starting deep research across documents...');
        const aggregatedSummaries = [];
        const relevantFiles = [];

        // First, determine which files are relevant based on keywords
        // This helps avoid sending empty documents to the AI and saves tokens/time
        // Iterate over the objects in availableContextFiles
        for (const fileInfo of availableContextFiles) { // MODIFIED
            const fileName = fileInfo.filename; // MODIFIED: Get the actual filename
            const normalizedQuestionWords = normalizedQuestionForAI.split(' ').filter(word => word.length > 0);
            const fileKeywords = documentKeywords[fileName]
                ? documentKeywords[fileName].flatMap(kw => kw.toLowerCase().replace(/[^\w\s']/g, '').split(' ')).filter(word => word.length > 0)
                : [];
            
            const score = normalizedQuestionWords.filter(qWord => fileKeywords.includes(qWord)).length;

            if (score > 0) { // Only include files with at least one matching keyword
                relevantFiles.push(fileName);
            }
        }

        if (relevantFiles.length === 0) {
          setError('No relevant documents found for deep research. Please refine your question or keywords.');
          setIsLoading(false);
          return;
        }

        // Loop through relevant files, summarize each, and aggregate
        for (let i = 0; i < relevantFiles.length; i++) {
          const fileName = relevantFiles[i];
          // Find the displayName for the progress message
          const fileDisplayName = availableContextFiles.find(f => f.filename === fileName)?.displayName || fileName.replace('.txt', ''); // MODIFIED
          setResearchProgress(`Analyzing document ${i + 1} of ${relevantFiles.length}: ${fileDisplayName}...`); // MODIFIED
          
          // Prepend import.meta.env.BASE_URL
          const filePath = `${import.meta.env.BASE_URL}context/${fileName}`;
          const response = await fetch(filePath);
          if (!response.ok) {
            console.warn(`Could not load document ${fileName} for research: ${response.statusText}`);
            continue; // Skip this file if it can't be loaded
          }
          const documentContent = await response.text();

          // Sub-query prompt for individual document summarization
          const subQueryPrompt = `Given the following document and the user's main question, extract and concisely summarize ONLY the information relevant to the question from THIS DOCUMENT. If no information is relevant, state 'No relevant information found in this document.'
          Document: """${documentContent}"""
          Main Question: "${normalizedQuestionForAI}"
          Summarize relevant information from this document:`;

          const subQueryResult = await fetch('https://openrouter.ai/api/v1/chat/completions', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${openRouterApiKey}`,
              'HTTP-Referer': window.location.href,
              'X-Title': 'SamaLore Contextual Q&A App - SubQuery'
            },
            body: JSON.stringify({
              model: 'nousresearch/hermes-3-llama-3.1-405b:free', // Reverted to Mistral Small
              messages: [{ role: 'user', content: subQueryPrompt }],
              // No response_format: { type: "json_object" } for sub-queries, expect plain text
            })
          });

          if (!subQueryResult.ok) {
            const errorData = await subQueryResult.json();
            console.error(`Sub-query API error for ${fileName}: ${subQueryResult.status} - ${errorData.message || 'Unknown error'}`);
            // If it's a 429, we might want to retry or increase delay. For now, just warn and continue.
            continue; // Continue to next file even if one fails
          }
          const subResultJson = await subQueryResult.json();
          const summary = subResultJson.choices[0]?.message?.content || 'No summary generated.';
          
          if (summary && summary.toLowerCase() !== 'no relevant information found in this document.') {
            aggregatedSummaries.push(`--- Summary from ${fileDisplayName} ---\n${summary}\n`); // MODIFIED
          }

          // Introduce a delay to avoid hitting rate limits
          await sleep(1500); // 1.5 second delay between sub-queries. Adjust if needed.
        }

        if (aggregatedSummaries.length === 0) {
          setError('No relevant information found across any documents for your question.');
          setIsLoading(false);
          return;
        }

        finalContextForAI = aggregatedSummaries.join('\n\n');
        finalSelectedFileName = 'Aggregated Research'; // Indicate this is a synthesized context
        setResearchProgress('Synthesizing final answer...');

        // Final Synthesis Prompt
        const finalPrompt = `You have been provided with multiple summaries from different documents, all related to the user's original question.
        Synthesize these summaries into a single, comprehensive 'exact_answer_text' and a 'tldr_summary'.
        For 'exact_answer_text', combine the most relevant details from the provided summaries into a coherent, detailed answer. Do not quote verbatim from the original documents, but rather integrate the information from the summaries.
        For 'tldr_summary', provide a concise, high-level overview and direct answer, potentially including external relations if they were part of the initial 'referencesAndRelations' context.

        Aggregated Summaries:
        """
        ${finalContextForAI}
        """

        Additional Reference Context (for external relations, do not directly quote into exact_answer_text):
        """
        ${referencesString}
        """

        Alternative Name Mappings (for understanding terms):
        """
        ${altNamesString}
        """

        Original Question: "${normalizedQuestionForAI}"

        Your response MUST be a JSON object with the following structure:
        {
          "matched_answers": [],
          "exact_answer_text": "A comprehensive, synthesized answer based on all provided summaries.",
          "tldr_summary": "A concise summary and direct answer to the question, potentially enriched by additional reference context."
        }
        `;

        const finalResponse = await fetch('https://openrouter.ai/api/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${openRouterApiKey}`,
            'HTTP-Referer': window.location.href,
            'X-Title': 'SamaLore Contextual Q&A App - Final Synthesis'
          },
          body: JSON.stringify({
            model: 'nousresearch/hermes-3-llama-3.1-405b:free', // Reverted to Mistral Small
            messages: [{ role: 'user', content: finalPrompt }],
            response_format: { type: "json_object" },
            schema: {
              type: "object",
              properties: {
                "matched_answers": { type: "array", items: { "type": "string" } },
                "exact_answer_text": { "type": "string" },
                "tldr_summary": { "type": "string" }
              },
              required: ["matched_answers", "exact_answer_text", "tldr_summary"]
            }
          })
        });

        if (!finalResponse.ok) {
          const errorData = await finalResponse.json();
          throw new Error(`Final synthesis API error: ${finalResponse.status} - ${errorData.message || 'Unknown error'}`);
        }

        const finalResult = await finalResponse.json();
        if (finalResult.choices && finalResult.choices.length > 0 && finalResult.choices[0].message && finalResult.choices[0].message.content) {
          const jsonResponse = finalResult.choices[0].message.content;
          const parsedJson = JSON.parse(jsonResponse);

          setMatchedAnswers(parsedJson.matched_answers || []); // Will be empty in this mode
          setExactAnswer(parsedJson.exact_answer_text || 'No comprehensive answer found.');
          setTldrSummary(parsedJson.tldr_summary || 'No summary available.');
        } else {
          setError('Failed to get a valid final synthesis response from the AI.');
          console.error('Final AI response structure unexpected or empty:', finalResult);
        }

      } else {
        // --- Standard Mode (Single Document Lookup) ---
        let contextToUse = currentContextContent;
        let finalSelectedFile = selectedContextFile;

        if (selectedContextFile === 'unsure') {
          finalSelectedFile = suggestContextFile(question);
          if (!finalSelectedFile) {
            setError('Could not determine a relevant document from your question. Please select a specific document or refine your question.');
            setIsLoading(false);
            return;
          }
          if (!currentContextContent || selectedContextFile !== finalSelectedFile) {
            setIsContextLoading(true);
            try {
              // Prepend import.meta.env.BASE_URL
              const response = await fetch(`${import.meta.env.BASE_URL}context/${finalSelectedFile}`); // MODIFIED
              if (!response.ok) throw new Error(`Failed to load suggested context file: ${response.statusText}`);
              contextToUse = await response.text();
              setCurrentContextContent(contextToUse);
            } catch (err) {
              setError(`Error loading suggested context: ${err.message}`);
              setIsLoading(false);
              setIsContextLoading(false);
              return;
            } finally {
              setIsContextLoading(false);
            }
          } else {
            contextToUse = currentContextContent;
          }
        }

        if (!contextToUse.trim()) {
          setError('Context document content is empty. Please ensure the selected file has content. This might happen if "Unsure" could not find a match.');
          setIsLoading(false);
          return;
        }

        // Standard Mode Prompt (for verbatim section extraction)
        const prompt = `Given the following primary context, additional reference context, and alternative name mappings, answer the question comprehensively.

        For 'exact_answer_text':
        Identify the *single most relevant section* in the PRIMARY context that directly answers or contains the information for the question.
        This section is typically defined by a prominent marker at its beginning (e.g., [Chapter 1], Verse 5:, ##Section Name, [Book Title], [Kunju Name], [About Kunju #1], [Kunju #1], [Name (Origin Part) - Sphere of Influence]).
        Extract the *entire, verbatim text* of this relevant section. This means copying all text from the identified starting marker up to, but not including, the next similar section marker, or until the end of the document if no further section markers are found.
        Include the section's defining marker in the extracted text. Do NOT summarize, paraphrase, or omit any part of this identified section.

        For 'tldr_summary':
        Provide a concise summary of the answer AND directly answer the question based on your understanding of the PRIMARY context. If relevant, and only if it naturally enhances the explanation, you may include information from the ADDITIONAL REFERENCE CONTEXT to provide external relations or common knowledge, but do not force it.

        Use the ALTERNATIVE NAME MAPPINGS to understand variations of names or terms mentioned in the question or context.

        Primary Context (from ${finalSelectedFile}):
        """
        ${contextToUse}
        """

        Additional Reference Context (for external relations, do not directly quote into exact_answer_text):
        """
        ${referencesString}
        """

        Alternative Name Mappings (use to understand alternate spellings/names):
        """
        ${altNamesString}
        """

        Question: "${normalizedQuestionForAI}"

        Your response MUST be a JSON object with the following structure. Do NOT include any other text or formatting outside this JSON structure.
        {
          "matched_answers": ["snippet 1", "snippet 2", ...],
          "exact_answer_text": "The full relevant section from the primary context, including its defining marker, copied verbatim.",
          "tldr_summary": "A concise summary and direct answer to the question, potentially enriched by additional reference context."
        }
        `;

        const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${openRouterApiKey}`,
            'HTTP-Referer': window.location.href,
            'X-Title': 'SamaLore Contextual Q&A App'
          },
          body: JSON.stringify({
            model: 'nousresearch/hermes-3-llama-3.1-405b:free', // Reverted to Mistral Small
            messages: [{ role: 'user', content: prompt }],
            response_format: { type: "json_object" },
            schema: {
              type: "object",
              properties: {
                "matched_answers": { type: "array", items: { "type": "string" } },
                "exact_answer_text": { "type": "string" },
                "tldr_summary": { "type": "string" }
              },
              required: ["matched_answers", "exact_answer_text", "tldr_summary"]
            }
          })
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(`OpenRouter API error: ${response.status} - ${errorData.message || 'Unknown error'}`);
        }

        const result = await response.json();

        if (result.choices && result.choices.length > 0 && result.choices[0].message && result.choices[0].message.content) {
          const jsonResponse = result.choices[0].message.content;
          const parsedJson = JSON.parse(jsonResponse);

          setMatchedAnswers(parsedJson.matched_answers || []);
          setExactAnswer(parsedJson.exact_answer_text || 'No exact answer found.');
          setTldrSummary(parsedJson.tldr_summary || 'No summary available.');
        } else {
          setError('Failed to get a valid response from the AI. The AI might not have returned the expected JSON format. Check console for raw response.');
          console.error('AI response structure unexpected or empty:', result);
        }
      }
    } catch (err) {
      setError(`An error occurred: ${err.message}. Check console for details.`);
      console.error('Fetch error:', err);
    } finally {
      setIsLoading(false);
      setResearchProgress(''); // Clear progress message
    }
  };

  const handleSelectAnswer = (answerText) => {
    console.log("Clicked matched answer snippet:", answerText);
    // For now, clicking a snippet does not change the main exactAnswer/tldrSummary,
    // as those are the AI's best overall response to the original question.
    // If you want to highlight the snippet within the exactAnswer, that's a UI enhancement.
  };

  // Handle .env file upload
  const handleEnvFileUpload = (e) => {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (event) => {
        const content = event.target.result;
        const match = content.match(/^OPENROUTER_API_KEY=(.*)$/m);
        if (match && match[1]) {
          const key = match[1].trim();
          setOpenRouterApiKey(key);
          sessionStorage.setItem('openRouterApiKey', key);
          setError('');
          alert('API Key loaded from .env file!'); // Using alert for simplicity, consider custom modal
        } else {
          setError('Could not find OPENROUTER_API_KEY in the .env file. Please check the format: OPENROUTER_API_KEY=your_key');
        }
      };
      reader.onerror = () => {
        setError('Error reading .env file.');
      };
      reader.readAsText(file);
    }
  };

  // Function to clear the entire instance
  const clearInstance = () => {
    setOpenRouterApiKey('');
    sessionStorage.removeItem('openRouterApiKey');
    setQuestion('');
    setSelectedContextFile('unsure');
    setCurrentContextContent('');
    setMatchedAnswers([]);
    setExactAnswer('');
    setTldrSummary('');
    setError('');
    setIsLoading(false);
    setIsContextLoading(false);
    setResearchProgress('');
    alert('Instance cleared! API Key removed from session storage.'); // Using alert for simplicity
  };

  return (
    <div className="min-h-screen bg-gray-100 p-4 font-sans flex flex-col items-center">
      <div className="w-full max-w-4xl bg-white rounded-lg shadow-xl p-6 space-y-6">
        {/* Application Title */}
        <h1 className="text-3xl font-bold text-center text-gray-800 mb-6">SamaLore Contextual Q&A App</h1>

        {/* API Key Input Section (with .env upload) */}
        <div className="bg-blue-50 p-4 rounded-md border border-blue-200">
          <label htmlFor="envFileUpload" className="block text-lg font-medium text-blue-800 mb-2">
            Upload OpenRouter API Key (.env file)
            <button
              onClick={() => setShowApiKeyHelp(!showApiKeyHelp)}
              className="ml-2 text-blue-600 hover:text-blue-800 font-bold text-xl leading-none"
              title="Click for API Key help"
            >
              ?
            </button>
          </label>
          <input
            type="file"
            id="envFileUpload"
            accept=".env"
            onChange={handleEnvFileUpload}
            className="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"
          />
          {openRouterApiKey && (
            <p className="mt-2 text-sm text-green-700">API Key loaded successfully!</p>
          )}

          {showApiKeyHelp && (
            <div className="mt-3 p-3 bg-blue-100 rounded-md text-blue-700 text-sm">
              <p className="font-semibold mb-2">How to get your OpenRouter API Key and create the .env file:</p>
              <ol className="list-decimal list-inside space-y-1">
                <li>Go to <a href="https://openrouter.ai/keys" target="_blank" rel="noopener noreferrer" className="text-blue-600 underline">OpenRouter.ai/keys</a></li>
                <li>Sign in or create an account.</li>
                <li>Click "Create New Key".</li>
                <li>Create a new file on your computer named `.env` (just `.env`, no filename before it).</li>
                <li>Inside this `.env` file, paste your copied API key in this format: <code className="font-mono bg-blue-200 p-1 rounded">OPENROUTER_API_KEY=your_copied_key_here</code></li>
                <li>Save the `.env` file and then upload it using the button above.</li>
              </ol>
              <p className="mt-2 font-semibold text-red-700">
                **Security Warning:** While this method avoids hardcoding, the key is still loaded into your browser's memory and session storage. For public applications, a secure backend (e.g., serverless function) is highly recommended to protect your API key. For internal use, ensure all users are aware of this.
              </p>
            </div>
          )}
        </div>

        {/* Context Document Selector, Question Input, and Ask Button */}
        <div className="flex flex-col gap-4">
          {/* Proper Research Checkbox */}
          <div className="flex items-center">
            <input
              type="checkbox"
              id="properResearchCheckbox"
              checked={isProperResearchMode}
              onChange={(e) => setIsProperResearchMode(e.target.checked)}
              className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
            />
            <label htmlFor="properResearchCheckbox" className="ml-2 block text-base font-medium text-gray-700">
              Enable Proper Research (multi-document analysis)
            </label>
          </div>

          {/* Context Document Selector */}
          <div>
            <label htmlFor="contextSelector" className="block text-lg font-medium text-gray-700 mb-2 whitespace-nowrap">
              Select Context Document (or type question for suggestion)
            </label>
            {isMetaDataLoading ? (
              <p className="text-gray-500">Loading context files and keywords...</p>
            ) : (
              <select
                id="contextSelector"
                className="w-full p-3 border border-gray-300 rounded-md bg-white focus:ring-blue-500 focus:border-blue-500"
                value={selectedContextFile}
                onChange={(e) => setSelectedContextFile(e.target.value)}
                disabled={isContextLoading || isMetaDataLoading || isProperResearchMode} // Disable if in proper research mode
              >
                <option value="unsure">Unsure (AI will suggest best document)</option>
                {/* MODIFIED: Use fileInfo.filename for value and fileInfo.displayName for display text */}
                {availableContextFiles.map((fileInfo, index) => (
                    <option key={index} value={fileInfo.filename}>
                        {fileInfo.displayName}
                    </option>
                ))}
              </select>
            )}
            {isContextLoading && selectedContextFile === 'unsure' && (
              <p className="text-sm text-gray-500 mt-1">AI is determining best context...</p>
            )}
            {isContextLoading && selectedContextFile !== 'unsure' && (
              <p className="text-sm text-gray-500 mt-1">Loading selected context...</p>
            )}
          </div>

          {/* Question Input Field and Ask Button - now aligned horizontally */}
          <div className="flex flex-col md:flex-row gap-4 items-end">
            <div className="flex-grow w-full">
              <label htmlFor="questionInput" className="block text-lg font-medium text-gray-700 mb-2">
                Your Question
              </label>
              <input
                type="text"
                id="questionInput"
                className="w-full p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500"
                value={question}
                onChange={(e) => setQuestion(e.target.value)}
                placeholder="e.g., What is the prophecy about Samaji?"
              />
            </div>
            <button
              onClick={handleAskQuestion}
              className="w-full md:w-auto px-6 py-3 bg-blue-600 text-white font-semibold rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition duration-200 ease-in-out"
              disabled={isLoading || isContextLoading || isMetaDataLoading || !openRouterApiKey || (!currentContextContent && selectedContextFile !== 'unsure' && !isProperResearchMode)}
            >
              {isLoading ? (researchProgress || 'Thinking...') : 'Ask Question'}
            </button>
          </div>
        </div>

        {/* Error Display Area */}
        {error && (
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative" role="alert">
            <strong className="font-bold">Error!</strong>
            <span className="block sm:inline"> {error}</span>
          </div>
        )}

        {/* Output Fields */}
        <div className="space-y-6">
          {/* List of Matched Answers */}
          <div>
            <h2 className="text-xl font-semibold text-gray-800 mb-3">List of Matched Answers:</h2>
            <div className="bg-gray-50 p-4 rounded-md border border-gray-200 min-h-[80px]">
              {matchedAnswers.length > 0 ? (
                <ul className="list-disc list-inside space-y-2">
                  {matchedAnswers.map((answer, index) => (
                    <li key={index}>
                      <button
                        onClick={() => handleSelectAnswer(answer)}
                        className="text-blue-600 hover:underline text-left"
                      >
                        {answer}
                      </button>
                    </li>
                  ))}
                </ul>
              ) : (
                <p className="text-gray-500">No matched answers yet. Ask a question!</p>
              )}
            </div>
          </div>

          {/* Exact Answer from Document */}
          <div>
            <h2 className="text-xl font-semibold text-gray-800 mb-3">Exact Answer from Document:</h2>
            <div className="bg-gray-50 p-4 rounded-md border border-gray-200 min-h-[120px] whitespace-pre-wrap">
              {exactAnswer ? (
                <p className="text-gray-700">{exactAnswer}</p>
              ) : (
                <p className="text-gray-500">The most relevant passage from the document will appear here.</p>
              )}
            </div>
          </div>

          {/* TLDR Summary */}
          <div>
            <h2 className="text-xl font-semibold text-gray-800 mb-3">TLDR Summary (Summary + AI's Answer):</h2>
            <div className="bg-gray-50 p-4 rounded-md border border-gray-200 min-h-[80px] whitespace-pre-wrap">
              {tldrSummary ? (
                <p className="text-gray-700">{tldrSummary}</p>
              ) : (
                <p className="text-gray-500">A concise summary and direct answer from the AI will appear here.</p>
              )}
            </div>
          </div>
        </div>

        {/* Clear Instance Button */}
        <div className="mt-6 text-center">
          <button
            onClick={clearInstance}
            className="px-6 py-3 bg-red-600 text-white font-semibold rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 transition duration-200 ease-in-out"
          >
            Clear Instance
          </button>
        </div>
      </div>
    </div>
  );
};

export default App;
